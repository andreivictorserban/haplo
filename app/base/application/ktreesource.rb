# Haplo Platform                                     http://haplo.org
# (c) Haplo Services Ltd 2006 - 2016    http://www.haplo-services.com
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.


# Javascript definition generator for KTreeSource javascript class

# TODO: Taxonomies in schema need to be constrained as well as those generated by the methods below.

class ApplicationController

  # Sync this with ktree.js
  KTREE_NODE_CHILDREN = 3

  KTREE_SEARCH_ENTRIES = 10

  # TODO: Handle addition to Types to Taxonomy browsing (/do/search/browse) in a less ugly manner?

  # selectable_objrefs is an Array of KObjRefs which should be selectable when the tree is loaded.
  # Anything else can only be selected once it's been selected by the user.
  def ktreesource_generate_taxonomy(selectable_objrefs = nil, include_types_root = false, store = KObjectStore.store)
    # Use :schema_user_version not :schema_version because this is the one which gets updated for subjects
    url = "/api/taxonomy/fetch?v=#{KApp.global(:schema_user_version)}&"
    ktreesource_generate(store, url, nil, KObjectStore.schema.hierarchical_classification_types(), selectable_objrefs, include_types_root)
  end

  def ktreesource_generate_root(store, root_node, node_types, selectable_objrefs, include_types_root = false)
    root_query_results = if root_node != nil then
      store.query_and.link_exact(root_node, A_PARENT).execute(:all, :title)
    else
      if node_types.empty?
        []
      else
        # Find all nodes of that type with no parent nodes
        q = store.query_and
          not_clause = q.not
            types_clause = not_clause.or
            node_types.each { |objref| types_clause.link_exact(objref, A_TYPE) }
          not_clause.link_to_any(A_PARENT)
        q.execute(:all, :title)
      end
    end

    root_level = Array.new
    root_query_results.each do |obj|
      root_level << [obj.first_attr(KConstants::A_TITLE).to_s, obj.objref.to_presentation, obj.first_attr(A_TYPE).to_presentation]
    end

    children_of_node = Hash.new   # hash of string objref -> children array

    if selectable_objrefs != nil
      selectable_objrefs.each do |objref|
        # Start
        scan = store.read(objref)
        child_ref = nil # ref of the current node's child
        limit = 32
        while scan != nil && limit > 0
          limit -= 1    # don't let this run away
          type = scan.first_attr(A_TYPE)
          # Already know about this one?
          ref = scan.objref.to_presentation
          children = children_of_node[ref]
          already_fetched_this_node = (children != nil)
          unless already_fetched_this_node
            # Find this node's children
            ch = store.query_and.link_exact(scan, A_PARENT)
            ch.link_exact(type, A_TYPE)
            children = Array.new
            ch.execute(:all, :title).each do |obj|
              children << [obj.first_attr(KConstants::A_TITLE).to_s, obj.objref.to_presentation]
            end

            children_of_node[ref] = children
          end

          # Patch in the child's record
          if child_ref != nil
            e = children.find { |i| i[1] == child_ref }
            e[KTREE_NODE_CHILDREN] = children_of_node[child_ref] if e != nil
          end
          child_ref = ref

          if already_fetched_this_node
            # Stop if we've already got the rest of the path to the root
            scan = nil
          else
            parent = scan.first_attr(A_PARENT)
            scan = (parent != nil) ? store.read(parent) : nil
          end
        end
      end

      # Patch in the children to the roots
      root_level.each do |r|
        c = children_of_node[r[1]]
        if c != nil
          r[KTREE_NODE_CHILDREN] = c
        end
      end
    end

    root_level << [T(:TreeSource_Browse_Types), 'TYPES', 'TYPES'] if include_types_root
    # TODO: Support loading of type nodes in tree source root generation so client side doesn't have to demand load type nodes immediately when one is selected via the URL (then change comment in j__treeSelectionChange in ksearch.rb)

    root_level
  end

  def ktreesource_generate(store, url, root_node, node_types, selectable_objrefs, include_types_root = false)
    root_level = ktreesource_generate_root(store, root_node, node_types, selectable_objrefs, include_types_root)
    # Create the HTML for sending the treesource data
    %Q!<div id="z__treesource_data" data-url="#{ERB::Util.h(url)}" data-tree="#{ERB::Util.h(root_level.to_json)}"></div>!
  end

  # ----------------------------------------------------------------
  # For controllers implementing fetch_api
  def ktreesource_fetch_api_implementation(include_types = false)
    if params.has_key?(:q)
      # Search query
      return ktreesource_fetch_api_implementation_search(include_types)
    end
    children_for = params[:children_for]
    objref = nil
    parent = nil
    children = Array.new
    # Types special case
    if include_types && children_for == 'TYPES'
      # ==== Type root
      objref = 'TYPES'
      KObjectStore.schema.root_type_descs_sorted_by_printable_name.each do |td|
        unless td.is_hidden_from_browse?
          children << [td.printable_name.to_s, td.objref.to_presentation]
        end
      end
    else
      # ==== Not a type root - parse objref
      objref = KObjRef.from_presentation(children_for)
      if objref != nil
        # Check it's not a schema object (if type taxonomy support has been included)
        type_desc = include_types ? KObjectStore.schema.type_descriptor(objref) : nil
        if type_desc != nil
          # Children of this type
          type_desc.children_types.each do |child_objref|
            td = KObjectStore.schema.type_descriptor(child_objref)
            unless td.is_hidden_from_browse?
              children << [td.printable_name.to_s, child_objref.to_presentation]
            end
          end
          parent = type_desc.parent_type || 'TYPES'
        else
          # Not a type -- query for children
          query = KObjectStore.query_and.link_exact(objref, A_PARENT)

          query.execute(:all, :title).each do |obj|
            children << [obj.first_attr(KConstants::A_TITLE).to_s, obj.objref.to_presentation]
          end

          # Find the parent of the node
          obj = KObjectStore.read(objref)
          parent = obj.first_attr(A_PARENT) if obj != nil
        end
      end
    end
    # Make JSON response
    if objref == nil || children == nil
      r = {}
    else
      r = {"children_of" => objref, "nodes" => children}
      r["parent"] = parent if parent
    end
    render :text => JSON.generate(r), :kind => :json
  end

  def ktreesource_fetch_api_implementation_search(include_types = false)
    text = params[:q].strip.split(/\s+/).map { |e| e + '*' } .join(' ')
    results = []
    if text.length > 0 && text =~ /\S/ && params.has_key?(:roots)
      # TODO: Handle TYPES in the roots of search lookups
      roots = params[:roots].split(',').map { |r| KObjRef.from_presentation(r) }.compact
      unless roots.empty?
        # Build query
        query = KObjectStore.query_and
        query.free_text(text, A_TITLE)
        roots_query = query.or
        roots.each { |r| roots_query.link(r, A_PARENT) }
        # Constraints etc
        query.add_exclude_labels([O_LABEL_STRUCTURE])
        query.maximum_results(KTREE_SEARCH_ENTRIES+1)
        # Cache for parent lookups
        lookup = Hash.new { |hash,key| hash[key] = KObjectStore.read(key) }
        # Generate results JSON
        results = query.execute(:all, :relevance).map do |obj|
          parents = []
          pfind = obj
          while parents.length < 4 && pfind != nil
            r = pfind.first_attr(A_PARENT)
            # Stop if a) no parent, or b) there's only one root, and it's that root (no point in displaying same parent for everything)
            if !(r) || ((roots.length == 1) && roots.include?(r))
              pfind = nil # so ellipsis addition below works
              break
            end
            pfind = lookup[r]
            parents << pfind.first_attr(A_TITLE).to_s
          end
          parents << '...' if pfind != nil
          titles = obj.all_attrs(A_TITLE)
          [obj.objref.to_presentation, titles.first.to_s, (titles.length > 1 ? titles[1].to_s : nil), parents.reverse.join(' > ')]
        end
      end
    end
    more_available = (results.length > KTREE_SEARCH_ENTRIES)
    results.pop if more_available # remove the last one in this case, so return the correct number
    render :text => {:results => results, :more => more_available}.to_json, :kind => :json
  end

end
